#!/usr/bin/env python
"""
Heuristic rule engine for entity matching.

This module loads and applies domain-specific heuristic rules generated by 
Claude Code SDK to improve matching accuracy.
"""

import json
import os
import pathlib
from typing import Dict, List, Optional, Callable, Any
from dataclasses import dataclass
import importlib.util
import sys


@dataclass
class HeuristicRule:
    """Represents a heuristic rule with its implementation"""
    rule_name: str
    description: str
    implementation: str
    confidence: float
    test_cases: List[Dict[str, Any]]
    compiled_function: Optional[Callable] = None


class HeuristicEngine:
    """Engine for loading and applying heuristic rules"""
    
    def __init__(self, dataset: str):
        self.dataset = dataset
        self.rules: List[HeuristicRule] = []
        self.compiled_rules: Dict[str, Callable] = {}
        
    def load_heuristics(self, heuristic_file: str) -> int:
        """Load heuristic rules from JSON file"""
        if not os.path.exists(heuristic_file):
            print(f"‚ö†Ô∏è  Heuristic file not found: {heuristic_file}")
            return 0
        
        try:
            with open(heuristic_file, 'r') as f:
                data = json.load(f)
            
            rules_data = data.get('rules', [])
            print(f"üìã Loading {len(rules_data)} heuristic rules for {self.dataset}")
            
            for rule_data in rules_data:
                rule = HeuristicRule(
                    rule_name=rule_data['rule_name'],
                    description=rule_data['description'],
                    implementation=rule_data['implementation'],
                    confidence=rule_data['confidence'],
                    test_cases=rule_data.get('test_cases', [])
                )
                
                # Compile the rule function
                if self._compile_rule(rule):
                    self.rules.append(rule)
                    print(f"  ‚úÖ {rule.rule_name} (confidence: {rule.confidence:.2f})")
                else:
                    print(f"  ‚ùå Failed to compile {rule.rule_name}")
            
            return len(self.rules)
            
        except Exception as e:
            print(f"Error loading heuristics: {e}")
            return 0
    
    def _compile_rule(self, rule: HeuristicRule) -> bool:
        """Compile a heuristic rule function"""
        try:
            # Create a temporary module to execute the function
            module_name = f"heuristic_{rule.rule_name}"
            
            # Add necessary imports to the function code
            function_code = f"""
import re
import math
from difflib import SequenceMatcher
from typing import Dict, Any, Optional

{rule.implementation}
"""
            
            # Compile and execute the function
            spec = importlib.util.spec_from_loader(module_name, loader=None)
            module = importlib.util.module_from_spec(spec)
            
            exec(function_code, module.__dict__)
            
            # Get the compiled function
            function_name = rule.rule_name
            if hasattr(module, function_name):
                rule.compiled_function = getattr(module, function_name)
                self.compiled_rules[rule.rule_name] = rule.compiled_function
                return True
            else:
                print(f"    Warning: Function {function_name} not found in compiled code")
                return False
                
        except Exception as e:
            print(f"    Error compiling rule {rule.rule_name}: {e}")
            return False
    
    def apply_heuristics(self, left_record: Dict[str, Any], right_record: Dict[str, Any]) -> float:
        """Apply all loaded heuristic rules to a record pair"""
        total_score_adjustment = 0.0
        
        for rule in self.rules:
            if rule.compiled_function:
                try:
                    # Apply the heuristic rule
                    score_adjustment = rule.compiled_function(left_record, right_record)
                    
                    # Weight by confidence
                    weighted_adjustment = score_adjustment * rule.confidence
                    total_score_adjustment += weighted_adjustment
                    
                except Exception as e:
                    # Don't let individual rule failures break the whole process
                    print(f"    Warning: Rule {rule.rule_name} failed: {e}")
                    continue
        
        return total_score_adjustment
    
    def test_heuristics(self, verbose: bool = False) -> Dict[str, bool]:
        """Test all loaded heuristics against their test cases"""
        print(f"üß™ TESTING {len(self.rules)} HEURISTIC RULES")
        
        results = {}
        
        for rule in self.rules:
            if not rule.compiled_function:
                results[rule.rule_name] = False
                continue
            
            print(f"\n  Testing {rule.rule_name}:")
            test_passed = True
            
            for i, test_case in enumerate(rule.test_cases):
                try:
                    left = test_case['left']
                    right = test_case['right']
                    expected = test_case['expected_result']
                    
                    result = rule.compiled_function(left, right)
                    
                    if verbose:
                        print(f"    Test {i+1}: {result} (expected: {expected})")
                    
                    # Basic test - just check if function runs without error
                    # More sophisticated testing would check the actual result
                    
                except Exception as e:
                    print(f"    ‚ùå Test {i+1} failed: {e}")
                    test_passed = False
            
            results[rule.rule_name] = test_passed
            status = "‚úÖ" if test_passed else "‚ùå"
            print(f"    {status} {rule.rule_name}")
        
        return results
    
    def get_rule_info(self) -> List[Dict[str, Any]]:
        """Get information about loaded rules"""
        return [
            {
                'rule_name': rule.rule_name,
                'description': rule.description,
                'confidence': rule.confidence,
                'compiled': rule.compiled_function is not None
            }
            for rule in self.rules
        ]


def load_heuristics_for_dataset(dataset: str, heuristic_file: Optional[str] = None) -> HeuristicEngine:
    """Load heuristics for a specific dataset"""
    engine = HeuristicEngine(dataset)
    
    if heuristic_file:
        # Use specified file
        engine.load_heuristics(heuristic_file)
    else:
        # Try to find heuristics file for this dataset
        possible_files = [
            f"{dataset}_heuristics.json",
            f"heuristics_{dataset}.json",
            f"data/heuristics/{dataset}.json"
        ]
        
        for file_path in possible_files:
            if os.path.exists(file_path):
                engine.load_heuristics(file_path)
                break
        else:
            print(f"‚ö†Ô∏è  No heuristics file found for dataset '{dataset}'")
            print(f"    Tried: {possible_files}")
    
    return engine


def test_heuristic_engine():
    """Test the heuristic engine with sample data"""
    print("üß™ TESTING HEURISTIC ENGINE")
    
    # Test with beer dataset heuristics
    engine = load_heuristics_for_dataset("beer", "beer_heuristics.json")
    
    if engine.rules:
        # Test the rules
        results = engine.test_heuristics(verbose=True)
        
        # Test with sample data
        sample_left = {
            "Beer_Name": "Amber Ale",
            "Brew_Factory_Name": "Mountain Goat Beer",
            "ABV": "5.0%",
            "Style": "American Amber / Red Ale"
        }
        
        sample_right = {
            "Beer_Name": "Red Ale",
            "Brew_Factory_Name": "Mountain Goat Beer Pty Ltd",
            "ABV": "5.2%",
            "Style": "Amber Ale"
        }
        
        print(f"\nüß™ TESTING WITH SAMPLE DATA:")
        print(f"Left: {sample_left}")
        print(f"Right: {sample_right}")
        
        score_adjustment = engine.apply_heuristics(sample_left, sample_right)
        print(f"Heuristic score adjustment: {score_adjustment:.3f}")
        
        # Show rule info
        print(f"\nüìã LOADED RULES:")
        for rule_info in engine.get_rule_info():
            print(f"  - {rule_info['rule_name']}: {rule_info['confidence']:.2f} confidence")
    
    return engine


if __name__ == "__main__":
    test_heuristic_engine()