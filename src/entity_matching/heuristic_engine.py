#!/usr/bin/env python
"""
Heuristic rule engine for entity matching.

This module loads and applies domain-specific heuristic rules generated by
Claude Code SDK to improve matching accuracy.
"""

import importlib.util
import json
import os

from dataclasses import dataclass
from typing import Any, Callable, Dict, List, Optional, Union


@dataclass
class CandidateAction:
    """Action to boost similarity during candidate generation"""

    similarity_boost: float
    confidence: float
    reason: str


@dataclass
class ScoreAction:
    """Action to adjust similarity score"""

    score_adjustment: float
    confidence: float
    reason: str


@dataclass
class DecisionAction:
    """Action to make early decision (auto-accept/reject)"""

    terminate_early: bool
    final_result: int  # 1 for match, 0 for no match
    confidence: float
    reason: str
    skip_llm: bool = False


@dataclass
class WeightAction:
    """Action to adjust semantic/trigram weights"""

    semantic_weight: float
    confidence: float
    reason: str


# Type alias for all possible actions
HeuristicAction = Union[CandidateAction, ScoreAction, DecisionAction, WeightAction, None]


@dataclass
class HeuristicRule:
    """Represents a heuristic rule with its implementation"""

    rule_name: str
    description: str
    implementation: str
    confidence: float
    stage: str  # candidate_generation, pre_llm, post_semantic, pre_semantic
    test_cases: List[Dict[str, Any]]
    compiled_function: Optional[Callable] = None


class HeuristicEngine:
    """Engine for loading and applying heuristic rules"""

    def __init__(self, dataset: str):
        self.dataset = dataset
        self.rules: List[HeuristicRule] = []
        self.compiled_rules: Dict[str, Callable] = {}
        # Organize rules by stage for efficient lookup
        self.rules_by_stage: Dict[str, List[HeuristicRule]] = {
            "candidate_generation": [],
            "pre_llm": [],
            "post_semantic": [],
            "pre_semantic": [],
        }

    def load_heuristics(self, heuristic_file: str) -> int:
        """Load heuristic rules from JSON file"""
        if not os.path.exists(heuristic_file):
            print(f"‚ö†Ô∏è  Heuristic file not found: {heuristic_file}")
            return 0

        try:
            with open(heuristic_file) as f:
                data = json.load(f)

            # Load categorized rules
            rule_categories = [
                ("candidate_rules", data.get("candidate_rules", [])),
                ("score_rules", data.get("score_rules", [])),
                ("decision_rules", data.get("decision_rules", [])),
                ("weight_rules", data.get("weight_rules", [])),
                ("pipeline_rules", data.get("pipeline_rules", [])),
            ]

            total_loaded = 0
            for category, rules_data in rule_categories:
                if not rules_data:
                    continue

                print(f"üìã Loading {len(rules_data)} {category} for {self.dataset}")

                for rule_data in rules_data:
                    rule = HeuristicRule(
                        rule_name=rule_data["rule_name"],
                        description=rule_data["description"],
                        implementation=rule_data["implementation"],
                        confidence=rule_data["confidence"],
                        stage=rule_data.get("stage", "post_semantic"),
                        test_cases=rule_data.get("test_cases", []),
                    )

                    # Compile the rule function
                    if self._compile_rule(rule):
                        self.rules.append(rule)
                        # Add to stage-specific list
                        if rule.stage in self.rules_by_stage:
                            self.rules_by_stage[rule.stage].append(rule)
                        print(f"  ‚úÖ {rule.rule_name} ({rule.stage}, confidence: {rule.confidence:.2f})")
                        total_loaded += 1
                    else:
                        print(f"  ‚ùå Failed to compile {rule.rule_name}")

            return total_loaded

        except Exception as e:
            print(f"Error loading heuristics: {e}")
            return 0

    def _compile_rule(self, rule: HeuristicRule) -> bool:
        """Compile a heuristic rule function"""
        try:
            # Create a temporary module to execute the function
            module_name = f"heuristic_{rule.rule_name}"

            # Add necessary imports and action classes to the function code
            function_code = f"""
import re
import math
from difflib import SequenceMatcher
from typing import Dict, Any, Optional, Union
from dataclasses import dataclass

# Action classes available to heuristic functions
@dataclass
class CandidateAction:
    similarity_boost: float
    confidence: float
    reason: str

@dataclass
class ScoreAction:
    score_adjustment: float
    confidence: float
    reason: str

@dataclass
class DecisionAction:
    terminate_early: bool
    final_result: int
    confidence: float
    reason: str
    skip_llm: bool = False

@dataclass
class WeightAction:
    semantic_weight: float
    confidence: float
    reason: str

# Utility functions
def normalize(text):
    '''Normalize text for comparison'''
    if not text:
        return ""
    return str(text).lower().strip()

def get_similarity(text1, text2):
    '''Get similarity between two texts'''
    return SequenceMatcher(None, normalize(text1), normalize(text2)).ratio()

{rule.implementation}
"""

            # Compile and execute the function
            spec = importlib.util.spec_from_loader(module_name, loader=None)
            module = importlib.util.module_from_spec(spec)

            exec(function_code, module.__dict__)

            # Get the compiled function
            function_name = rule.rule_name
            if hasattr(module, function_name):
                rule.compiled_function = getattr(module, function_name)
                self.compiled_rules[rule.rule_name] = rule.compiled_function
                return True
            print(f"    Warning: Function {function_name} not found in compiled code")
            return False

        except Exception as e:
            print(f"    Error compiling rule {rule.rule_name}: {e}")
            return False

    def apply_heuristics(self, left_record: Dict[str, Any], right_record: Dict[str, Any]) -> float:
        """Apply score heuristic rules to a record pair"""
        return self.apply_stage_heuristics("post_semantic", left_record, right_record)

    def apply_stage_heuristics(
        self,
        stage: str,
        left_record: Dict[str, Any],
        right_record: Dict[str, Any],
        current_score: Optional[float] = None,
    ) -> Union[float, HeuristicAction]:
        """Apply heuristic rules for a specific stage"""
        if stage not in self.rules_by_stage:
            return 0.0 if stage != "candidate_generation" else None

        total_score_adjustment = 0.0
        actions = []

        for rule in self.rules_by_stage[stage]:
            if rule.compiled_function:
                try:
                    # Apply the heuristic rule
                    if stage == "pre_llm" and current_score is not None:
                        result = rule.compiled_function(left_record, right_record, current_score)
                    else:
                        result = rule.compiled_function(left_record, right_record)

                    if result is None:
                        continue

                    # Handle different action types
                    if isinstance(result, (CandidateAction, ScoreAction, DecisionAction, WeightAction)):
                        actions.append(result)
                    elif isinstance(result, (int, float)):
                        # Legacy score adjustment
                        weighted_adjustment = float(result) * rule.confidence
                        total_score_adjustment += weighted_adjustment

                except Exception as e:
                    # Don't let individual rule failures break the whole process
                    print(f"    Warning: Rule {rule.rule_name} failed: {e}")
                    continue

        # Return appropriate result based on stage
        if stage == "candidate_generation":
            # For candidate generation, return the first CandidateAction or None
            candidate_actions = [a for a in actions if isinstance(a, CandidateAction)]
            return candidate_actions[0] if candidate_actions else None
        if stage == "pre_llm":
            # For pre_llm, return the first DecisionAction or score adjustment
            decision_actions = [a for a in actions if isinstance(a, DecisionAction)]
            if decision_actions:
                return decision_actions[0]
        elif stage == "pre_semantic":
            # For pre_semantic, return the first WeightAction or None
            weight_actions = [a for a in actions if isinstance(a, WeightAction)]
            return weight_actions[0] if weight_actions else None

        # For post_semantic and other stages, return score adjustments
        score_actions = [a for a in actions if isinstance(a, ScoreAction)]
        for action in score_actions:
            total_score_adjustment += action.score_adjustment * action.confidence

        return total_score_adjustment

    def test_heuristics(self, verbose: bool = False) -> Dict[str, bool]:
        """Test all loaded heuristics against their test cases"""
        print(f"üß™ TESTING {len(self.rules)} HEURISTIC RULES")

        results = {}

        for rule in self.rules:
            if not rule.compiled_function:
                results[rule.rule_name] = False
                continue

            print(f"\n  Testing {rule.rule_name}:")
            test_passed = True

            for i, test_case in enumerate(rule.test_cases):
                try:
                    left = test_case["left"]
                    right = test_case["right"]
                    expected = test_case["expected_result"]

                    result = rule.compiled_function(left, right)

                    if verbose:
                        print(f"    Test {i + 1}: {result} (expected: {expected})")

                    # Basic test - just check if function runs without error
                    # More sophisticated testing would check the actual result

                except Exception as e:
                    print(f"    ‚ùå Test {i + 1} failed: {e}")
                    test_passed = False

            results[rule.rule_name] = test_passed
            status = "‚úÖ" if test_passed else "‚ùå"
            print(f"    {status} {rule.rule_name}")

        return results

    def get_rule_info(self) -> List[Dict[str, Any]]:
        """Get information about loaded rules"""
        return [
            {
                "rule_name": rule.rule_name,
                "description": rule.description,
                "confidence": rule.confidence,
                "compiled": rule.compiled_function is not None,
            }
            for rule in self.rules
        ]


def load_heuristics_for_dataset(dataset: str, heuristic_file: Optional[str] = None) -> HeuristicEngine:
    """Load heuristics for a specific dataset"""
    engine = HeuristicEngine(dataset)

    if heuristic_file:
        # Use specified file
        engine.load_heuristics(heuristic_file)
    else:
        # Try to find heuristics file for this dataset
        possible_files = [f"{dataset}_heuristics.json", f"heuristics_{dataset}.json", f"data/heuristics/{dataset}.json"]

        for file_path in possible_files:
            if os.path.exists(file_path):
                engine.load_heuristics(file_path)
                break
        else:
            print(f"‚ö†Ô∏è  No heuristics file found for dataset '{dataset}'")
            print(f"    Tried: {possible_files}")

    return engine


def test_heuristic_engine():
    """Test the heuristic engine with sample data"""
    print("üß™ TESTING HEURISTIC ENGINE")

    # Test with beer dataset heuristics
    engine = load_heuristics_for_dataset("beer", "beer_heuristics.json")

    if engine.rules:
        # Test the rules
        engine.test_heuristics(verbose=True)

        # Test with sample data
        sample_left = {
            "Beer_Name": "Amber Ale",
            "Brew_Factory_Name": "Mountain Goat Beer",
            "ABV": "5.0%",
            "Style": "American Amber / Red Ale",
        }

        sample_right = {
            "Beer_Name": "Red Ale",
            "Brew_Factory_Name": "Mountain Goat Beer Pty Ltd",
            "ABV": "5.2%",
            "Style": "Amber Ale",
        }

        print("\nüß™ TESTING WITH SAMPLE DATA:")
        print(f"Left: {sample_left}")
        print(f"Right: {sample_right}")

        score_adjustment = engine.apply_heuristics(sample_left, sample_right)
        print(f"Heuristic score adjustment: {score_adjustment:.3f}")

        # Show rule info
        print("\nüìã LOADED RULES:")
        for rule_info in engine.get_rule_info():
            print(f"  - {rule_info['rule_name']}: {rule_info['confidence']:.2f} confidence")

    return engine


if __name__ == "__main__":
    test_heuristic_engine()
